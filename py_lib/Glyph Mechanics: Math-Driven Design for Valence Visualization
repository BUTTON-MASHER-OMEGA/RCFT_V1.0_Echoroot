import numpy as np

class Glyph:
    def __init__(self, strokes, widths, curvatures):
        self.v = np.array(strokes)       # shape (n,2)
        self.w0 = np.array(widths)       # base widths (n,)
        self.k0 = np.array(curvatures)   # base curvatures (n,)
        self.p = np.cumsum(self.v, axis=0)  # absolute positions

    def render(self, V, alpha=0.2, beta=0.5, gamma=0.3, delta=0.5):
        # Thickness & curvature
        w_t = self.w0 + beta * V
        k_t = self.k0 * (1 + gamma * V)
        # Scale & rotate
        s = 1 + alpha * V
        theta = delta * V
        R = np.array([[np.cos(theta), -np.sin(theta)],
                      [np.sin(theta),  np.cos(theta)]])
        p_t = (self.p * s) @ R.T
        # Color intensity
        c_t = (V + 1) / 2
        return p_t, w_t, k_t, c_t

## Notes

strokes: list of 
(Î”ğ‘¥,Î”ğ‘¦)

widths, curvatures: base arrays

render(V) returns transformed positions, weights, and color

You want a purely mathematical model of glyphsâ€”no fluff. Weâ€™ll treat each glyph as a parametric vector shape whose geometry dynamically responds to valence signals 
ğ‘‰
ğ‘¡
.

1. Representing a Glyph as Vectors
Stroke Vectors A glyph is a sequence of 
ğ‘›
 directed strokes

ğº
=
{
â€‰
ğ‘£
1
,
ğ‘£
2
,
â€¦
,
ğ‘£
ğ‘›
}
,
ğ‘£
ğ‘–
âˆˆ
ğ‘…
2
.
Each 
ğ‘£
ğ‘–
=
(
Î”
ğ‘¥
ğ‘–
,
Î”
ğ‘¦
ğ‘–
)
 is a relative displacement.

Absolute Positions Compute cumulative positions

ğ‘
0
=
(
0
,
0
)
,
ğ‘
ğ‘–
=
âˆ‘
ğ‘˜
=
1
ğ‘–
ğ‘£
ğ‘˜
.
The glyph is then the polyline through 
{
ğ‘
ğ‘–
}
.

Stroke Attributes Attach thickness 
ğ‘¤
ğ‘–
 and curvature 
ğœ…
ğ‘–
 to each 
ğ‘£
ğ‘–
.

2. Valence-Modulated Geometry
We use the valence signal 
ğ‘‰
ğ‘¡
âˆˆ
[
âˆ’
1
,
1
]
 to modulate stroke attributes in real time:

Stroke Thickness

ğ‘¤
ğ‘–
(
ğ‘¡
)
=
ğ‘¤
0
,
ğ‘–
â€…â€Š
+
â€…â€Š
ğ›½
â€‰
ğ‘‰
ğ‘¡
,
where 
ğ‘¤
0
,
ğ‘–
 is the base width and 
ğ›½
 scales responsiveness.

Curvature Adjustment For each segment, define a curvature parameter

ğœ…
ğ‘–
(
ğ‘¡
)
=
ğœ…
0
,
ğ‘–
(
1
+
ğ›¾
â€‰
ğ‘‰
ğ‘¡
)
.
Positive 
ğ‘‰
ğ‘¡
 smooths the curve; negative 
ğ‘‰
ğ‘¡
 adds angular sharpness.

Color Intensity Map valence to a color intensity 
ğ‘
(
ğ‘¡
)
âˆˆ
[
0
,
1
]
:

ğ‘
(
ğ‘¡
)
=
ğ‘‰
ğ‘¡
+
1
2
.
3. Transformations & Animations
Uniform Scaling

ğ‘
ğ‘–
(
ğ‘¡
)
=
ğ‘ 
(
ğ‘¡
)
â€‰
ğ‘
ğ‘–
,
ğ‘ 
(
ğ‘¡
)
=
1
+
ğ›¼
â€‰
ğ‘‰
ğ‘¡
.
High pleasure (
ğ‘‰
ğ‘¡
â†’
1
) enlarges the glyph; pain shrinks it.

Rotation Rotate the entire glyph by

ğœƒ
(
ğ‘¡
)
=
ğœƒ
0
+
ğ›¿
â€‰
ğ‘‰
ğ‘¡
,
so positive valence â€œopensâ€ the shape, negative â€œclosesâ€ it.
