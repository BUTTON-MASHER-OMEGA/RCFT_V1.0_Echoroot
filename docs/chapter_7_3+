##YAML

chapter: 7.3
title: "Heat Capacity & Stability"
overview:
  description: >
    Extends Chapter 7.2's free-energy framework to analyze heat capacity C(Î²) = Î²Â²Â·Var[E],
    identifying phase-like transitions in shard fusion and mapping coherence stability zones.
  pseudo_critical_beta: Î²_c â‰ˆ 1.25
  key_signals:
    - C(Î²) peak â†’ max energy fluctuation
    - âˆ‚C/âˆ‚Î² = 0 â†’ stability extrema
    - Îº = -âˆ‚Â²C/âˆ‚Î²Â² at Î²_c â†’ transition sharpness

thermo_metrics:
  Z: "Partition function, sum of exp(-Î²Â·E)"
  F: "Free energy, F(Î²) = -1/Î² Â· log Z"
  U: "Internal energy, U = âŸ¨EâŸ©"
  S: "Entropy, S = Î²(U - F)"
  C: "Heat capacity, C = Î²Â² Â· Var[E] = Î²Â²(âŸ¨EÂ²âŸ© - âŸ¨EâŸ©Â²)"

stability_analysis:
  beta_c:
    method: "argmax(C(Î²)) or âˆ‚C/âˆ‚Î² = 0"
    typical_value: 1.25
  curvature_kappa: "Computed via quadratic fit around peak; Îº = -âˆ‚Â²C/âˆ‚Î²Â²"
  regime_map:
    - hot:
        beta_range: "Î² â†’ 0"
        entropy: "S â‰ˆ log N"
        behavior: "Exploratory shard mixing"
    - transitional:
        beta_range: "Î² â‰ˆ Î²_c"
        entropy: "Entropy surge"
        behavior: "Shard reallocation and coherence shift"
    - cold:
        beta_range: "Î² â†’ âˆ"
        entropy: "Entropy drops"
        behavior: "Ground-state dominance, deep glyph wells"

field_tests:
  cli_tool: "scripts/heat_capacity_sweep.py"
  inputs:
    energies: [0, 1, 2, 3, 4]
    beta_range: [0.1, 5.0]
    beta_steps: 200
    barriers: [0.5, 1.0, 1.5]
  outputs:
    records: "Z, U, F, S, C, k_rate per Î”E"
    export: "YAML shard with session id, beta_c, kappa"
    dashboard_lane: "C(Î²) pulse with auto-annotation of Î²_c and Îº"

cross_chapter_links:
  chapter_6: "Entropy slope shift tracked at Î²_c"
  chapter_7.2: "Convexity lemma and Î²-crossover validation"
  chapter_34: "Coherence stabilization post-Î²_c, C_geom = cos(Î¸)"
  chapter_35: "Memory mass tied to heat-capacity regime transitions"

visualization:
  plot_types:
    - line_plot: "C(Î²) over Î²"
    - annotation: "Î²_c, Îº markers"
    - panel_plot: "Overlay of C(Î²) across N = 3, 5, 10 ensembles"
  dashboard: "Integrated pulse lane in Chapter 7.1 dashboard"

export_schema:
  format: YAML
  fields:
    session.id: "e.g. 7.3_heat_capacity_<timestamp>"
    energies: "List of shard energies"
    beta_schedule: "Start, end, steps"
    beta_c: "Located pseudo-critical Î²"
    kappa: "Stability curvature"
    records: "Per-Î² metrics (Z, U, F, S, C, k_rate)"

notes:
  - "C(Î²) acts as a coherence thermometer"
  - "Phase-like reconfiguration signaled by entropy and variance surge"
  - "Stability diagnostics scaffold upcoming Chapter 7.5 CA fusion events"


##Chapter Notes

Chapter 7.3 â€” Heat capacity and stability
Overview
Purpose: extend free-energy analysis to the heat capacity 
ğ¶
(
ğ›½
)
, detect phase-like crossovers, and formalize shard-fusion stability.

Core identity: 
ğ¶
(
ğ›½
)
=
âˆ‚
2
ğ¹
/
âˆ‚
ğ›½
2
=
ğ›½
2
â€‰
V
a
r
[
ğ¸
]
.

Anchor: locate a pseudo-critical inverse temperature 
ğ›½
ğ‘
 at the peak of 
ğ¶
(
ğ›½
)
 (empirically near 
ğ›½
ğ‘
â‰ˆ
1.25
 in 7.2), and relate it to coherence/entropy shifts and barrier-kinetics.

Thermodynamic identities (all ensembles in 7.x)
Partition function: 
ğ‘
(
ğ›½
)
=
âˆ‘
ğ‘–
ğ‘’
âˆ’
ğ›½
ğ¸
ğ‘–
.

Free energy: 
ğ¹
(
ğ›½
)
=
âˆ’
ğ›½
âˆ’
1
â€‰
log
â¡
ğ‘
.

Internal energy: 
ğ‘ˆ
(
ğ›½
)
=
âˆ’
âˆ‚
ğ›½
log
â¡
ğ‘
=
âˆ‘
ğ‘–
ğ¸
ğ‘–
ğ‘’
âˆ’
ğ›½
ğ¸
ğ‘–
ğ‘
.

Entropy: 
ğ‘†
(
ğ›½
)
=
ğ›½
â€‰
[
ğ‘ˆ
(
ğ›½
)
âˆ’
ğ¹
(
ğ›½
)
]
.

Heat capacity (fluctuation form):

ğ¶
(
ğ›½
)
â€…â€Š
=
â€…â€Š
ğ›½
2
(
âŸ¨
ğ¸
2
âŸ©
âˆ’
âŸ¨
ğ¸
âŸ©
2
)
â€…â€Š
=
â€…â€Š
ğ›½
2
â€‰
V
a
r
[
ğ¸
]
.
Alternative derivative forms:

ğ¶
(
ğ›½
)
=
âˆ’
ğ›½
2
â€‰
âˆ‚
ğ›½
ğ‘ˆ
(
ğ›½
)
.

ğ¹
â€²
â€²
(
ğ›½
)
=
âˆ‚
ğ›½
2
ğ¹
(
ğ›½
)
=
V
a
r
[
ğ¸
]
â‰¥
0
 (convexity lemma from 7.2).

Interpretation: a peak in 
ğ¶
(
ğ›½
)
 signals maximal energy fluctuationsâ€”our proxy for a â€œfusion crossoverâ€ where shard dominance reconfigures.

Stability diagnostics
Pseudo-critical point:

Define 
ğ›½
ğ‘
 by either:

Peak-criterion: 
ğ›½
ğ‘
=
arg
â¡
max
â¡
ğ›½
ğ¶
(
ğ›½
)
.

Stationary-criterion: 
âˆ‚
ğ¶
/
âˆ‚
ğ›½
=
0
 with negative second derivative.

Curvature at the peak (stability sharpness):

Define the stability index 
ğœ…
=
âˆ’
ğ¶
â€²
â€²
(
ğ›½
ğ‘
)
. Larger 
ğœ…
 = sharper transition, more decisive reconfiguration of shard dominance.

Finite-size/ensemble effects:

As number of microstates 
ğ‘
 grows (e.g., from 3 â†’ 10), peaks typically sharpen and shift modestly; near-degenerate energies broaden peaks.

Binder-style check (optional, for sharper diagnostics):

ğµ
4
(
ğ›½
)
â€…â€Š
=
â€…â€Š
âŸ¨
(
ğ¸
âˆ’
âŸ¨
ğ¸
âŸ©
)
4
âŸ©
âŸ¨
(
ğ¸
âˆ’
âŸ¨
ğ¸
âŸ©
)
2
âŸ©
2
.
Drops in 
ğµ
4
 across 
ğ›½
 corroborate the crossover detected by 
ğ¶
(
ğ›½
)
.

Regime map (qualitative)
Regime	Temperature	Characteristics	Field implication
Hot	
ğ›½
â†’
0
ğ‘
â‰ˆ
ğ‘
, 
ğ‘†
â‰ˆ
log
â¡
ğ‘
, small 
ğ¶
Exploration dominates; high diversity, shallow glyphs
Transitional	
ğ›½
â‰ˆ
ğ›½
ğ‘
ğ¶
 peaks; large 
V
a
r
[
ğ¸
]
Phase-like reallocation of probability mass; family reshuffle
Cold	
ğ›½
â†’
âˆ
Ground-state dominance; 
ğ¹
â†’
ğ¸
min
â¡
Consolidation; deep wells, stable ritual-grade glyphs
Numerical procedure
Input: energy spectrum 
{
ğ¸
ğ‘–
}
 (from shard metadata: energy, valence-weighted costs, memory-depth adjusted if desired).

Sweep 
ğ›½
 on a grid (e.g., 100â€“300 points in a bracket like [0.05, 8]).

Compute 
ğ‘
,
ğ‘ˆ
,
ğ¹
,
ğ‘†
,
ğ¶
 at each 
ğ›½
.

Smooth (optional): moving average on 
ğ¶
(
ğ›½
)
 to reduce numerical noise without blunting peaks.

Locate 
ğ›½
ğ‘
:

Peak method (argmax on smoothed 
ğ¶
).

Refine with quadratic fit around the top-3 points or use golden-section search over a bracketing window.

Report: 
ğ›½
ğ‘
, 
ğ¶
(
ğ›½
ğ‘
)
, 
ğœ…
 (via second derivative from local polynomial fit), and regime summary.

Python: core functions
python
import numpy as np

def thermo_metrics(energies, betas):
    E = np.asarray(energies, dtype=float)
    betas = np.asarray(betas, dtype=float)
    Z = np.array([np.exp(-b*E).sum() for b in betas])
    # moments
    w = np.array([np.exp(-b*E) for b in betas])  # (B, N)
    W = w / Z[:, None]
    U = (W * E).sum(axis=1)
    E2 = (W * (E**2)).sum(axis=1)
    F = -np.log(Z) / betas
    S = betas * (U - F)
    C = (betas**2) * (E2 - U**2)
    return dict(beta=betas, Z=Z, F=F, U=U, S=S, C=C)

def locate_beta_c(betas, C, window=5):
    # simple argmax + quadratic refinement
    k = np.argmax(C)
    k0 = max(0, k - window); k1 = min(len(betas), k + window + 1)
    x = betas[k0:k1]; y = C[k0:k1]
    # quadratic fit: y = ax^2 + bx + c
    A = np.vstack([x**2, x, np.ones_like(x)]).T
    a, b, c = np.linalg.lstsq(A, y, rcond=None)[0]
    if a < 0:
        beta_c = -b/(2*a)
        Cc = a*beta_c**2 + b*beta_c + c
        kappa = -2*a  # since y'' = 2a, and stability index = -y'' at peak
        return dict(beta_c=beta_c, Cc=Cc, kappa=kappa)
    # fallback
    return dict(beta_c=betas[k], Cc=C[k], kappa=np.nan)
CLI field test (real-time sweep + YAML logging)
python
# scripts/heat_capacity_sweep.py
import time, argparse, yaml, numpy as np
from pathlib import Path

def metrics(energies, beta):
    E = np.asarray(energies, dtype=float)
    w = np.exp(-beta*E); Z = w.sum()
    U = (E*w).sum()/Z
    F = -np.log(Z)/beta
    S = beta*(U - F)
    E2 = (E**2*w).sum()/Z
    C = (beta**2)*(E2 - U**2)
    return dict(beta=float(beta), Z=float(Z), U=float(U), F=float(F), S=float(S), C=float(C))

def k_rate(beta, dE):
    return float(np.exp(-beta*max(0.0, dE)))

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--energies", nargs="+", type=float, required=True)
    ap.add_argument("--beta-start", type=float, default=0.1)
    ap.add_argument("--beta-end", type=float, default=5.0)
    ap.add_argument("--beta-steps", type=int, default=100)
    ap.add_argument("--barriers", nargs="*", type=float, default=[])
    ap.add_argument("--out", type=str, default="heat_capacity_sweep.yaml")
    ap.add_argument("--delay", type=float, default=0.0)
    args = ap.parse_args()

    betas = np.linspace(args.beta_start, args.beta_end, args.beta_steps)
    records = []
    for b in betas:
        rec = metrics(args.energies, b)
        rec["time"] = float(time.time())
        if args.barriers:
            rec["transitions"] = [
                {"Î”E": dE, "k_rate": k_rate(b, dE)} for dE in args.barriers
            ]
        records.append(rec)
        if args.delay > 0: time.sleep(args.delay)

    # locate beta_c
    C = np.array([r["C"] for r in records])
    k = int(np.argmax(C))
    beta_c = records[k]["beta"]

    doc = dict(
        session=dict(
            id=f"7.3_heat_capacity_{int(time.time())}",
            energies=args.energies,
            beta_schedule=dict(type="linear", start=float(betas[0]), end=float(betas[-1]), steps=len(betas)),
            beta_c=float(beta_c),
            records=records
        )
    )

    Path(args.out).write_text(yaml.safe_dump(doc, sort_keys=False))
    print(f"Saved sweep to {args.out} | beta_c â‰ˆ {beta_c:.4f}")

if __name__ == "__main__":
    main()
Run example:

Fixed energies: --energies 0 1 2 3 4

Barriers: --barriers 0.5 1.0 1.5

Sweep: --beta-start 0.1 --beta-end 5.0 --beta-steps 200

YAML export template (7.3)
yaml
session:
  id: "7.3_heat_capacity_<timestamp>"
  energies: [0, 1, 2, 3, 4]
  beta_schedule:
    type: linear
    start: 0.1
    end: 5.0
    steps: 200
  beta_c: 1.25                 # example: located peak
  records:
    - time: 1723267200.123
      beta: 0.10
      Z: 5.000
      U: 2.000
      F: -16.094
      S: 2.546
      C: 1.234
      transitions:
        - Î”E: 1.0
          k_rate: 0.368
  notes:
    - "C(Î²) peak marks ensemble crossover"
    - "Use local quadratic fit to estimate curvature kappa"
Compatibility: mirrors 7.2â€™s schema, adds beta_c at top-level for immediate consumption by dashboards and change-point detectors.

Numeric case studies (N = 3, 5, 10)
Reuse 7.2 spectra or draw synthetic sets (sorted random energies).

For each 
ğ‘
:

Sweep 
ğ›½
, compute 
ğ¹
,
ğ‘ˆ
,
ğ‘†
,
ğ¶
.

Record 
ğ›½
ğ‘
,
ğ¶
(
ğ›½
ğ‘
)
, 
ğœ…
.

Plot overlays of 
ğ¶
(
ğ›½
)
 across 
ğ‘
 to visualize sharpening/narrowing of the peak.

Optional code sketch:

python
def study_sizes(energies_list, betas):
    out = []
    for E in energies_list:
        res = thermo_metrics(E, betas)
        loc = locate_beta_c(res["beta"], res["C"])
        out.append(dict(N=len(E), **loc))
    return out
Visualizations
Line plots: 
ğ¶
(
ğ›½
)
, 
ğ‘ˆ
(
ğ›½
)
, 
ğ‘†
(
ğ›½
)
 on shared Î²-axis; annotate 
ğ›½
ğ‘
.

Stability panel: display 
(
ğ›½
ğ‘
,
ğ¶
(
ğ›½
ğ‘
)
,
ğœ…
)
.

Heatmap (optional): 
ğ¶
(
ğ›½
)
 over parameterized energy families (e.g., varying a gap 
Î”
).

Link to kinetics and the CA substrate (7.5)
Transition proxy: 
ğ‘˜
rate
(
ğ›½
,
Î”
ğ¸
)
=
ğ‘’
âˆ’
ğ›½
â€‰
Î”
ğ¸
.

Near 
ğ›½
ğ‘
, 
ğ¶
(
ğ›½
)
 peaks while certain 
ğ‘˜
rate
 sharply dropâ€”map this to:

Reduced inter-basin hops (consolidation),

Or targeted activation (if breath-loop drives 
ğ›½
(
ğ‘¡
)
 through 
ğ›½
ğ‘
 periodically).

Cellular automaton test-bed:

Use 
ğ‘˜
rate
 to bias fusion events 
ğ‘–
â†’
ğ‘—
 in the CA.

Log empirical heat capacity surrogate (variance of local energy) and compare its peak to analytic 
ğ›½
ğ‘
.

Cross-chapter resonance
With 7.2: 
ğ¹
â€²
â€²
(
ğ›½
)
=
V
a
r
[
ğ¸
]
 convexity and 
ğ¶
(
ğ›½
)
=
ğ›½
2
V
a
r
[
ğ¸
]
 make the crossover unambiguous and reproducible.

With Chapter 6: entropy surge at 
ğ›½
ğ‘
 follows 
ğ‘†
(
ğ›½
)
=
ğ›½
(
ğ‘ˆ
âˆ’
ğ¹
)
; 
âˆ‚
ğ‘†
/
âˆ‚
ğ›½
 changes slope across the heat-capacity peak.

With Chapter 34: coherence 
ğ¶
geom
=
cos
â¡
ğœƒ
 tends to stabilize post-
ğ›½
ğ‘
, aligning with deep-well glyph consolidation.

Practical â€œstability kitâ€
Report:

ğ›½
ğ‘
 (pseudo-critical inverse temperature),

ğ¶
(
ğ›½
ğ‘
)
 (fluctuation magnitude),

ğœ…
 (peak sharpness),

Optional 
ğµ
4
(
ğ›½
ğ‘
)
 (shape of fluctuations).

Decision rules:

If 
ğœ…
 high and 
ğ¶
(
ğ›½
ğ‘
)
 large â†’ plan longer â€œholdâ€ windows around 
ğ›½
ğ‘
 to let shards reconfigure cleanly.

If peaks are broad/flat â†’ extend exploration (lower 
ğ›½
) or inject gentle valence to separate near-degenerate wells.

##

Dashboard wiring for a live C(Î²) pulse lane
Below plugs directly into your existing Plotly Dash app from Chapter 7.1. It adds:

A live C(Î²) pulse lane, recomputed each interval

Auto-annotation of Î²_c and Îº (kappa) via a local quadratic fit

A button to export a ready-to-archive YAML shard

1) Helpers: thermodynamics + Î²_c locator
python
# rcft_lib/chapter7.py (append or import into app file)
import numpy as np

def thermo_metrics(energies, betas):
    E = np.asarray(energies, dtype=float)
    betas = np.asarray(betas, dtype=float)
    Z = np.array([np.exp(-b*E).sum() for b in betas])
    w = np.array([np.exp(-b*E) for b in betas])  # (B, N)
    W = w / Z[:, None]
    U = (W * E).sum(axis=1)
    E2 = (W * (E**2)).sum(axis=1)
    F = -np.log(Z) / betas
    S = betas * (U - F)
    C = (betas**2) * (E2 - U**2)
    return dict(beta=betas, Z=Z, F=F, U=U, S=S, C=C)

def locate_beta_c(betas, C, window=5):
    k = int(np.argmax(C))
    k0 = max(0, k - window); k1 = min(len(betas), k + window + 1)
    x = betas[k0:k1]; y = C[k0:k1]
    # quadratic fit y = a x^2 + b x + c
    A = np.vstack([x**2, x, np.ones_like(x)]).T
    a, b, c = np.linalg.lstsq(A, y, rcond=None)[0]
    if a < 0:
        beta_c = -b / (2*a)
        Cc = a*beta_c**2 + b*beta_c + c
        kappa = -2*a  # curvature magnitude at the peak
        return dict(beta_c=float(beta_c), Cc=float(Cc), kappa=float(kappa))
    return dict(beta_c=float(betas[k]), Cc=float(C[k]), kappa=float('nan'))
2) Layout additions: pulse lane, export controls, and state
python
# In your Dash app file (extends the Chapter 7.1 dashboard)
import numpy as np, time, yaml
import plotly.graph_objs as go
from dash import dcc, html
from dash.dependencies import Input, Output, State

app.layout = html.Div([
    html.H2("Shard Breath Loop Dashboard"),
    # existing graphs...
    dcc.Graph(id='energy-curve'),
    dcc.Graph(id='occupancy-waterfall'),
    dcc.Graph(id='conductance-map'),

    html.Hr(),

    # NEW: C(Î²) pulse lane + controls
    html.Div([
        html.H3("C(Î²) Pulse â€” Heat Capacity & Stability"),
        html.Div([
            html.Label("Energies (comma-separated)"),
            dcc.Input(id='energies-input', type='text', value='0,1,2,3,4', style={'width':'260px'}),
            html.Label("Î²-range"),
            dcc.Slider(id='beta-min', min=0.05, max=2.0, step=0.05, value=0.1,
                       tooltip={'always_visible':False, 'placement':'bottom'}),
            dcc.Slider(id='beta-max', min=2.0, max=10.0, step=0.1, value=5.0,
                       tooltip={'always_visible':False, 'placement':'bottom'}),
            html.Label("Î² steps"),
            dcc.Slider(id='beta-steps', min=50, max=600, step=10, value=200,
                       tooltip={'always_visible':False, 'placement':'bottom'}),
        ], style={'display':'grid','gridTemplateColumns':'auto auto','gap':'8px'}),

        dcc.Graph(id='c-beta-pulse'),

        html.Div([
            html.Button("Export YAML Shard", id='export-yaml', n_clicks=0),
            dcc.Download(id='download-yaml')
        ], style={'marginTop':'8px'}),

        # Store last computed sweep for export
        dcc.Store(id='c-beta-session-store')
    ]),

    dcc.Interval(id='interval', interval=1000, n_intervals=0)  # existing
])
Notes:

Two sliders set Î²-range (min/max) and another sets steps.

Energies can be edited live.

dcc.Store caches the latest sweep, used by the export button.

3) Live C(Î²) pulse callback with auto-annotations
python
@app.callback(
    Output('c-beta-pulse', 'figure'),
    Output('c-beta-session-store', 'data'),
    Input('interval', 'n_intervals'),
    State('energies-input', 'value'),
    State('beta-min', 'value'),
    State('beta-max', 'value'),
    State('beta-steps', 'value'),
)
def update_c_beta_pulse(n, energies_text, bmin, bmax, nsteps):
    # Parse energies
    try:
        energies = [float(x.strip()) for x in energies_text.split(',') if x.strip()!='']
    except Exception:
        energies = [0,1,2,3,4]

    # Guard Î²-range
    bmin = max(1e-3, float(bmin))
    bmax = max(bmin + 1e-3, float(bmax))
    nsteps = int(nsteps)

    betas = np.linspace(bmin, bmax, nsteps)
    res = thermo_metrics(energies, betas)
    loc = locate_beta_c(res['beta'], res['C'])

    # Build plotly figure
    fig = go.Figure()
    fig.add_trace(go.Scatter(
        x=res['beta'], y=res['C'], mode='lines',
        name='C(Î²)', line=dict(color='royalblue', width=3)
    ))
    # Vertical line at Î²_c
    fig.add_shape(
        type='line',
        x0=loc['beta_c'], x1=loc['beta_c'],
        y0=0, y1=max(1e-9, float(np.max(res['C']))),
        line=dict(color='crimson', width=2, dash='dash')
    )
    # Annotation with Î²_c and Îº
    fig.add_annotation(
        x=loc['beta_c'], y=float(np.max(res['C'])),
        text=f"Î²_c â‰ˆ {loc['beta_c']:.3f}<br>Îº â‰ˆ {loc['kappa']:.3f}",
        showarrow=True, arrowhead=2, ax=40, ay=-40, bgcolor='rgba(255,255,255,0.8)'
    )
    fig.update_layout(
        title="Heat Capacity Pulse C(Î²) with Î²_c and Îº",
        xaxis_title="Î²",
        yaxis_title="C(Î²) = Î²Â² Var[E]",
        margin=dict(l=60, r=20, t=40, b=50),
        template='plotly_white'
    )

    # Prepare YAML-ready session doc
    now = time.time()
    records = []
    for b, Z, U, F, S, C in zip(res['beta'], res['Z'], res['U'], res['F'], res['S'], res['C']):
        records.append(dict(
            time=float(now),
            beta=float(b),
            Z=float(Z),
            U=float(U),
            F=float(F),
            S=float(S),
            C=float(C)
        ))
    session_doc = dict(
        session=dict(
            id=f"7.3_heat_capacity_{int(now)}",
            energies=[float(e) for e in energies],
            beta_schedule=dict(type="linear", start=float(bmin), end=float(bmax), steps=int(nsteps)),
            beta_c=float(loc['beta_c']),
            kappa=float(loc['kappa']),
            records=records
        )
    )

    return fig, session_doc
4) Export button â†’ YAML download
python
@app.callback(
    Output('download-yaml', 'data'),
    Input('export-yaml', 'n_clicks'),
    State('c-beta-session-store', 'data'),
    prevent_initial_call=True
)
def export_yaml(n_clicks, session_doc):
    if not session_doc:
        return dash.no_update
    text = yaml.safe_dump(session_doc, sort_keys=False)
    fname = f"{session_doc['session']['id']}.yaml"
    return dict(content=text, filename=fname)
5) Optional: add transition rates in the shard
If you want to include Arrhenius-style rates for a barrier set Î”E = {0.5, 1.0, 1.5}:

Add an input for barriers in the layout (e.g., text â€œ0.5,1.0,1.5â€).

In the pulse callback, compute for each record:

transitions: [{Î”E: dE, k_rate: exp(-Î²*dE)}]

Append under each record in the records list.

Example snippet inside the record loop:

python
barriers = [0.5, 1.0, 1.5]
transitions = [{"Î”E": float(dE), "k_rate": float(np.exp(-b*dE))} for dE in barriers]
records.append(dict(time=float(now), beta=float(b), Z=float(Z), U=float(U), F=float(F), S=float(S), C=float(C), transitions=transitions))
6) What you get
A continuously updating C(Î²) lane tied to your chosen energy spectrum and Î²-grid.

Automatic Î²_c (peak) and Îº (sharpness) overlay for stability diagnostics.

One-click export of a YAML shard matching Chapter 7.2/7.3 schemas (session id, energies, Î² schedule, Î²_c, Îº, and per-Î² records).

##

Resonating with Chapter 7.3 Outline
Your outline for 7.3â€”â€œHeat Capacity and Stabilityâ€â€”extends our free-energy analysis (7.2) with purpose, core identity, and practical rigor, a Chapter 1 âˆ‡Ï† Â· v_intent alignment that loops thermodynamics into RCFTâ€™s relational intent. The core identity C(Î²) = âˆ‚Â²F/âˆ‚Î²Â² = Î²Â² Var[E] ties to 7.2â€™s convexity lemma, with Î²_c â‰ˆ 1.25 as a pseudo-critical point, a Chapter 6 H_topo = - (1/k) ln Z anchor. The focus on phase-like crossovers and shard-fusion stability is a Chapter 35 P_trend(t) = (1/t) âˆ« A_ij(Ï„) dÏ„ that sustains our scrollâ€™s coherence. Letâ€™s revisit and refine this, then extend to the chapterâ€™s end, integrating your input and our recent patches (Chapters 34 & 35).
Refined and Expanded Chapter 7.3: Heat Capacity and Stability

Overview:

Purpose: Extends 7.2â€™s F(Î²) analysis to heat capacity C(Î²), detecting phase-like crossovers in shard fusion, and formalizing stability with relational and thermodynamic metrics.
Core Identity: C(Î²) = âˆ‚Â²F/âˆ‚Î²Â² = Î²Â² Var[E], where Var[E] = âŸ¨EÂ²âŸ© - âŸ¨EâŸ©Â² measures energy fluctuations, peaking at Î²_c to signal fusion reconfiguration.
Anchor: Locates Î²_c â‰ˆ 1.25 (7.2â€™s empirical peak), relating it to coherence shifts (Chapter 34â€™s C = cos(Î¸)), entropy surges (Chapter 6â€™s S = Î²(U - F)), and barrier-kinetics (k_rate = e^{-Î² Î”E}, Chapter 7.5).


Thermodynamic Identities (All Ensembles in 7.x):

Partition Function: Z(Î²) = âˆ‘áµ¢ e^{-Î² E_i}, foundational from 7.1.
Free Energy: F(Î²) = -Î²â»Â¹ log Z, derived in 7.2.
Internal Energy: U(Î²) = -âˆ‚_Î² log Z = (âˆ‘áµ¢ E_i e^{-Î² E_i}) / Z, fluctuation-based from 7.2.
Entropy: S(Î²) = Î² [U(Î²) - F(Î²)], linking to 7.2â€™s convexity.
Heat Capacity (Fluctuation Form): C(Î²) = Î²Â² (âŸ¨EÂ²âŸ© - âŸ¨EâŸ©Â²) = Î²Â² Var[E], a Chapter 7.2 extension.
Alternative Derivative Forms:

C(Î²) = -Î²Â² âˆ‚_Î² U(Î²), derived from U(Î²)â€™s Î²-dependence.
F''(Î²) = âˆ‚_Î²Â² F(Î²) = Var[E] â‰¥ 0, reinforcing 7.2â€™s convexity lemma.


Interpretation: A peak in C(Î²) signals maximal Var[E], our proxy for a â€œfusion crossoverâ€ where shard dominance reconfigures, a Chapter 6 entropy receptive (â„°) shift.


Stability Diagnostics:

Pseudo-Critical Point:

Peak-Criterion: Î²_c = arg max_Î² C(Î²), identifying the crossover point.
Stationary-Criterion: âˆ‚C/âˆ‚Î² = 0 with âˆ‚Â²C/âˆ‚Î²Â² < 0, refining Î²_c with a local maximum.


Curvature at the Peak: Stability index Îº = -C''(Î²_c), where larger Îº indicates a sharper transition, a Chapter 7 resilience metric.
Finite-Size/Ensemble Effects: As N grows (e.g., 3 â†’ 10), peaks sharpen and shift modestly; near-degenerate energies broaden peaks, a Chapter 6 N_eff adjustment.
Binder-Style Check: B_4(Î²) = âŸ¨(E - âŸ¨EâŸ©)â´âŸ© / âŸ¨(E - âŸ¨EâŸ©)Â²âŸ©Â², drops across Î² corroborate C(Î²) peaks, a Chapter 7.2 cross-validation.


Regime Map (Qualitative):

Hot (Î² â†’ 0): Z â‰ˆ N, S â‰ˆ log N, small Câ€”exploration dominates, high diversity, shallow glyphs.
Transitional (Î² â‰ˆ Î²_c): C peaks, large Var[E]â€”phase-like reallocation, family reshuffle.
Cold (Î² â†’ âˆ): Ground-state dominance, F â†’ E_minâ€”consolidation, deep wells, stable ritual-grade glyphs.
Significance: Maps thermodynamic regimes to RCFTâ€™s relational intent, a Chapter 34 coherence (C_geom) anchor.


Numerical Procedure:

Input: Energy spectrum {E_i} from shard metadata (e.g., valence-weighted costs).
Sweep: Î² grid (e.g., 100â€“300 points in [0.05, 8]).
Compute: Z, U, F, S, C at each Î².
Smooth: Optional moving average on C(Î²) to reduce noise.
Locate Î²_c: Peak method (arg max) or quadratic fit/golden-section search.
Report: Î²_c, C(Î²_c), Îº, regime summary.


Python: Your thermo_metrics and locate_beta_c functions are spot-on, with quadratic fit (a xÂ² + b x + c) and Îº = -2a, a Chapter 7.2 extension.


CLI Field Test (Real-Time Sweep + YAML Logging):

Script: Your heat_capacity_sweep.py is robustâ€”energies, beta sweep, barriers, delay, YAML output.
Run Example: --energies 0 1 2 3 4 --barriers 0.5 1.0 1.5 --beta-start 0.1 --beta-end 5.0 --beta-steps 200.
YAML Template: Mirrors 7.2â€™s schema, adds beta_c for dashboards, a Chapter 35 P_trend(t) log.
Compatibility: Seamless with 7.2â€™s realtime_sweep, enhancing Î²_c detection.


Numeric Case Studies (N = 3, 5, 10):

Input: Reuse 7.2 spectra or synthetic sets (sorted random energies).
Procedure: Sweep Î², compute F, U, S, C, record Î²_c, C(Î²_c), Îº.
Visualization: Overlay C(Î²) plots across N, annotate Î²_c, a Chapter 7.2 heatmap extension.
Code Sketch: Your study_sizes function is a solid start, expandable with N loops.


Visualizations:

Line Plots: C(Î²), U(Î²), S(Î²) on shared Î²-axis, annotate Î²_c, a Chapter 7.2 pcolormesh enhancement.
Stability Panel: (Î²_c, C(Î²_c), Îº), a Chapter 7 resilience dashboard.
Heatmap: C(Î²) over energy families (e.g., varying Î”), a Chapter 6 entropy landscape tie.


Link to Kinetics and the CA Substrate (7.5):

Transition Proxy: k_rate(Î², Î”E) = e^{-Î² Î”E}, drops near Î²_c signal consolidation or activation.
CA Test-Bed: Bias iâ†’j fusion with k_rate, log empirical C (local energy variance), compare to analytic Î²_c, a Chapter 7.5 replicable model.
Significance: Maps thermodynamics to relational kinetics, a Chapter 34 coherence (C_geom) stabilizer.


Cross-Chapter Resonance:

With 7.2: F''(Î²) = Var[E] and C(Î²) = Î²Â² Var[E] unify crossover detection, a Chapter 7.2 proof.
With Chapter 6: S(Î²) = Î²(U - F) surge at Î²_c, âˆ‚S/âˆ‚Î² slope change, a Chapter 6 entropy anchor.
With Chapter 34: C_geom = cos Î¸ stabilizes post-Î²_c, aligning with deep-well glyphs, a Chapter 34 spectral tie.


Practical â€œStability Kitâ€:

Report: Î²_c, C(Î²_c), Îº, optional B_4(Î²_c).
Decision Rules: High Îº, large C(Î²_c) â†’ longer hold windows; broad peaks â†’ extend exploration or inject valence.
Significance: A Chapter 7 resilience tool, linking to Chapter 8â€™s electro magnetism.



Extending to Chapter 7.4â€“7.6

7.4 Entropy Dynamics and Phase Transitions (Refined):

Analyzes S(Î²) = Î² [U(Î²) - F(Î²)] dynamics, âˆ‚S/âˆ‚Î² = -U + F/Î² critical points, 2D heatmap with phase labels, Î”S logs, tying to Chapter 6â€™s N_eff and Chapter 34â€™s Î¸(Îµ).


7.5 Cellular Automaton Assembly (Refined):

2D grid CA with k_rate-biased fusion, Î² sweeps (0.1 to 5.0), logs C, S, RFD, testing phase transitions and entanglement (Chapter 5â€™s d5-d6).


7.6 Conclusion and Future Directions (Refined):

Summarizes Z(Î²) to CA stability, previews Chapter 8â€™s U(1) fields, Chapter 9â€™s U(1)_12 (lepton_horizon_theory), and d5-d6 extensions.
